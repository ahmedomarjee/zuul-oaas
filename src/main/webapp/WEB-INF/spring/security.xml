<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:jee="http://www.springframework.org/schema/jee"
       xmlns:sec="http://www.springframework.org/schema/security"
       xmlns:oauth="http://www.springframework.org/schema/security/oauth2"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
       http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.1.xsd
       http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.1.xsd
       http://www.springframework.org/schema/security/oauth2 http://www.springframework.org/schema/security/spring-security-oauth2-1.0.xsd">


    <!--////////// Security Configuration //////////-->


    <!--///// HTTP Filters /////-->

    <!--
        Token endpoint
        Used by the clients to obtain an access token by presenting its authorization
        grant or refresh token.
    -->
    <sec:http pattern="${token.endpoint}"
              create-session="stateless"
              entry-point-ref="oauthAuthenticationEntryPoint"
              access-decision-manager-ref="accessDecisionManager"
              authentication-manager-ref="clientAuthenticationManager">

        <sec:intercept-url pattern="${token.endpoint}" access="IS_AUTHENTICATED_FULLY" />
        <sec:anonymous enabled="false" />
        <sec:http-basic entry-point-ref="oauthAuthenticationEntryPoint" />
        <!-- include this only if you need to authenticate clients via request parameters -->
        <sec:custom-filter ref="clientCredentialsTokenEndpointFilter" before="BASIC_AUTH_FILTER" />
        <sec:access-denied-handler ref="oauthAccessDeniedHandler" />
    </sec:http>

    <!--
        Check Token Endpoint
        Used by resource providers to verify tokens received from clients.
    -->
<!--    <sec:http pattern="/check-token/**"
              create-session="stateless"
              entry-point-ref="oauthAuthenticationEntryPoint"
              authentication-manager-ref="clientAuthenticationManager"
              use-expressions="true">

         scope 'token-check' is deprecated and will be removed in future version 
        <sec:intercept-url pattern="/check-token/**"
                           access="(#oauth2.hasScope('urn:ctu:oauth:oaas:check-token')
                                   or #oauth2.hasScope('token-check'))
                                   and #oauth2.isClient()" />

        <sec:custom-filter ref="checkTokenResourcesFilter" before="PRE_AUTH_FILTER" />
        <sec:access-denied-handler ref="oauthAccessDeniedHandler" />
        <sec:expression-handler ref="oauthWebExpressionHandler" />
    </sec:http>-->

    <!--
        API resources
        Used for management of this authorization server.
    -->
    <sec:http pattern="/api/v1/**"
              create-session="stateless"
              entry-point-ref="oauthAuthenticationEntryPoint"
              authentication-manager-ref="clientAuthenticationManager"
              use-expressions="true">

        <!-- 'ROLE_BIG_BOSS' is deprecated any may be removed in future version, use scope instead -->
        <sec:intercept-url pattern="/api/v1/clients/**"
                           access="(#oauth2.hasScope('urn:ctu:oauth:oaas:manager')
                                   or #oauth2.clientHasRole('ROLE_BIG_BOSS'))
                                   and #oauth2.isClient()" />

        <sec:intercept-url pattern="/api/v1/resources/**"
                           access="permitAll"
                           method="GET" />

        <sec:intercept-url pattern="/api/v1/resources/**"
                           access="(#oauth2.hasScope('urn:ctu:oauth:oaas:manager')
                                   or #oauth2.clientHasRole('ROLE_BIG_BOSS'))
                                   and #oauth2.isClient()" />
        
        <sec:intercept-url pattern="/api/v1/tokens/**"
                           access="(#oauth2.hasScope('urn:ctu:oauth:oaas:manager')
                                   or #oauth2.clientHasRole('ROLE_BIG_BOSS'))
                                   and #oauth2.isClient()" />

        <sec:custom-filter ref="API_ResourcesFilter" before="PRE_AUTH_FILTER" />
        <sec:access-denied-handler ref="oauthAccessDeniedHandler" />
        <sec:expression-handler ref="oauthWebExpressionHandler" />
    </sec:http>

    <!--
        Web page for users login
    -->
    <sec:http access-denied-page="/login.html?authorization_error=true"
              disable-url-rewriting="true"
              access-decision-manager-ref="accessDecisionManager"
              authentication-manager-ref="userAuthenticationManager">

        <sec:intercept-url pattern="/oauth/**" access="IS_AUTHENTICATED_FULLY" />

        <sec:form-login login-page="/login.html"
                        login-processing-url="/login.do"
                        default-target-url="/"
                        authentication-failure-url="/login.html?authentication_error=true" />

        <sec:logout logout-url="/logout.do" logout-success-url="/" />
        <sec:anonymous />
    </sec:http>



    <!--///// Custom filters /////-->

    <!--
        Filter that supports client authentication with credentials in request body (parameters client_id and client_secret).
        Note: This method of authentication is not recommended by OAuth specification (draft-ietf-oauth-v2-31, 16)!
              Clients shoud use HTTP Basic scheme instead.
    -->
    <bean id="clientCredentialsTokenEndpointFilter" class="org.springframework.security.oauth2.provider.client.ClientCredentialsTokenEndpointFilter"
          p:authenticationManager-ref="clientAuthenticationManager" />

    <oauth:resource-server id="checkTokenResourcesFilter"
                           token-services-ref="tokenServices" />

    <oauth:resource-server id="API_ResourcesFilter"
                           resource-id="ctu-oauth-server"
                           token-services-ref="tokenServices" />



    <!--///// Entry points & handlers /////-->

    <!--
        OAuth2 security expression handler for ACL declarations
        See http://static.springsource.org/spring-security/site/docs/3.0.x/reference/el-access.html
    -->
    <oauth:web-expression-handler id="oauthWebExpressionHandler" />

    <bean id="oauthAccessDeniedHandler" class="org.springframework.security.oauth2.provider.error.OAuth2AccessDeniedHandler" />

    <!--
        Client authentication with HTTP Basic scheme. This is the recommended way by specification.
    -->
    <bean id="oauthAuthenticationEntryPoint" class="org.springframework.security.oauth2.provider.error.OAuth2AuthenticationEntryPoint" />



    <!--///// Managers /////-->

    <bean id="accessDecisionManager" class="org.springframework.security.access.vote.UnanimousBased">
        <constructor-arg>
            <list>
                <bean class="org.springframework.security.oauth2.provider.vote.ScopeVoter" />
                <bean class="org.springframework.security.access.vote.RoleVoter" />
                <bean class="org.springframework.security.access.vote.AuthenticatedVoter" />
            </list>
        </constructor-arg>
    </bean>

    <sec:authentication-manager id="clientAuthenticationManager">
        <sec:authentication-provider user-service-ref="clientUserDetailsService" />
    </sec:authentication-manager>



    <!--///// Users authentication /////-->

    <beans profile="dev">
        <sec:authentication-manager id="userAuthenticationManager">
            <sec:authentication-provider>
                <sec:user-service>
                    <sec:user name="tomy" password="best" authorities="ROLE_USER" />
                </sec:user-service>
            </sec:authentication-provider>
        </sec:authentication-manager>
    </beans>

    <beans profile="ldap">
        
        <!--context mapper to create FIT LDAP user object-->
        <bean id="extendedFITUserDetailsContextMapper" class="cz.cvut.appsmanager.service.help.ExtendedUserDetailsContextMapper" 
              p:firstnameAttributeName="${ldap.fit.attribute.name.fn}"
              p:lastnameAttributeName="${ldap.fit.attribute.name.sn}"
              p:emailAttributeName="${ldap.fit.attribute.name.email}"
              p:passwordAttributeName="${ldap.fit.attribute.name.password}" />
        
        <jee:jndi-lookup id="ldapServerUri" jndi-name="java:comp/env/conf/ldapServerUri"
                         cache="true" default-value="ldap://localhost/ou=dummy" />

        <sec:ldap-server url="${ldap.fit.server.uri}" />

        <sec:authentication-manager id="userAuthenticationManager">
            <!-- Remote users from LDAP -->
            <sec:ldap-authentication-provider user-dn-pattern="uid={0},ou=People" />
        </sec:authentication-manager>
    </beans>
    
    <beans profile="ldap-2">
        
        <!--context mapper to create FIT LDAP user object-->
        <bean id="extendedFITUserDetailsContextMapper" class="cz.cvut.authserver.oauth2.support.ExtendedUserDetailsContextMapper" 
              p:firstnameAttributeName="${ldap.fit.attribute.name.fn}"
              p:lastnameAttributeName="${ldap.fit.attribute.name.sn}"
              p:emailAttributeName="${ldap.fit.attribute.name.email}"
              p:passwordAttributeName="${ldap.fit.attribute.name.password}" />

        <!--context mapper to create FET LDAP user object-->
        <bean id="extendedFELUserDetailsContextMapper" class="cz.cvut.authserver.oauth2.support.ExtendedUserDetailsContextMapper" 
              p:firstnameAttributeName="${ldap.fel.attribute.name.fn}"
              p:lastnameAttributeName="${ldap.fel.attribute.name.sn}"
              p:emailAttributeName="${ldap.fel.attribute.name.email}"
              p:passwordAttributeName="${ldap.fel.attribute.name.password}" />
        
        <sec:ldap-server id="ldapFIT" url="${ldap.fit.server.uri}" />
        <sec:ldap-server id="ldapFEL" url="${ldap.fel.server.uri}" />

        <sec:authentication-manager id="userAuthenticationManager">
            <!-- Remote users from LDAP -->
            <sec:ldap-authentication-provider server-ref="ldapFEL" user-dn-pattern="uid={0},ou=People" user-context-mapper-ref="extendedFELUserDetailsContextMapper"/>
            <sec:ldap-authentication-provider server-ref="ldapFIT" user-dn-pattern="uid={0},ou=People" user-context-mapper-ref="extendedFITUserDetailsContextMapper"/>
        </sec:authentication-manager>
    </beans>

    
</beans>
